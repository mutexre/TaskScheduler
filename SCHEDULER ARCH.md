# Архитектура универсального планировщика

## Синтаксис описания ограничений
Для задания дополнительных ограничений можно использовать простой DSL или JSON-формат.<br>

Пример DSL:

- Условие "AFTER": задача i идёт строго после задачи j: ```i after j;```
- Условие "DEADLINE_PENALTY": штраф за нарушение дедлайна для задачи k: ```deadline_penalty <task_index> <penalty_value>;```

При записи в виде EBNF-грамматики:
```
grammar            = { line } ;
line               = [ constraint ] EOL ;
constraint         = afterConstraint | deadlinePenaltyConstraint ;
afterConstraint    = integer "after" integer ;
deadlinePenaltyConstraint = "deadline_penalty" integer integer ;
```

Либо то же в JSON:

```json
[
  { "type": "after", "task_i": 3, "task_j": 1 },
  { "type": "deadline_penalty", "task": 2, "penalty": 10 },
]
```

В архитектуре присутствует базовый интерфейс модели/решателя который позволяет абстрагировать детали реализации различных библиотек и отдельных решателей. Интерфейс должен поддерживать описание ограничений, целевых функций, выставление дополнительных параметров решателя, таких как ограничение по времени или количеству итераций.

Планировщик будет реализован в качестве класса который хранит базовый набор ограничений (см. "Детали реализации"), а так же динамический список дополнительных ограничений. Класс должен поддерживать методы для инспекции и обновления списка дополнительных ограничений.

Перед началом поиска решения, планировщик объединяет два списка, вызывает соответствующие функции модели для обновления списка ограничений и целевой функции.

Класс универсального планировщика должен поддерживать кэширование результата. Для этого в классе определяется логический флаг is_solution_valid который выставляется в значение false в тот момент когда изменяется список диначиских ограничений. По умолчанию, значение флага установлено в false, что означает отсутсвие решения в данный момент. Значение флага должно быть доступно пользователям класса

## Общая идея и компоненты
### Класс UniversalScheduler

- Хранит базовые ограничения: последовательное выполнение, выполнение только одной задачи в любой момент времени и т.д.
- Позволяет добавлять и удалять динамические ограничения, записанные либо через DSL, либо в формате JSON.
- Имеет публичные методы для:
  - Инспекция списка ограничений (инспекция текущего состояния).
  - Обновление текущих ограничений (например, добавить условие ```i after j```).
  - Установки дополнительных параметров решателя (лимит по времени, номер итераций, уровень логирования и т.д.).
  - Запуска решения с учётом всех ограничений.
  - Следит за флагом is_solution_valid, указывающим, нужно ли пересобирать модель и заново решать задачу.
  - Получение текущего результата.
  - Установка объекта (модели) который производит решение задачи поиска оптимальной конфигарации.

### Парсинг ограничений

- Модуль, отвечающий за преобразование входных данных (DSL или JSON) в класс Constraint, понятный для внутреннего кода.
- В случае DSL-формата используется парсер, который опирается на EBNF-грамматику.
- Для JSON достаточно распарсить ключи JSON.

### Интерфейс “Модель/Солвер”

- Абстрагирует библиотеку CVXPY (или другие) и конкретные решатели (SCIP, Gurobi, CPLEX...).
- Предоставляет методы:
  - add_constraint(...) — добавить новое ограничение,
  - set_objective(...) — задать целевую функцию,
  - solve(...) — запустить решение с заданными параметрами (time_limit, verbose и т.д.).
- Универсальный планировщик вызывает эти методы, чтобы модифицировать модель.

### Хранилище результатов

- После успешного вызова solve(...) планировщик получает расписание.
- Хранит результат в кеше и выставляет is_solution_valid = true.
- Если позже пользователь меняет набор дополнительных ограничений, флаг сбрасывается в false, сигнализируя, что результат устарел и требуется пересчёт.

## Последовательность работы

### Инициализация

- Создаётся объект UniversalScheduler. Автоматически задаются базовые ограничения.
- Устанавливается значение is_solution_valid = false.

### Загрузка динамических ограничений

- Пользователь передаёт строки DSL или JSON.
- Вызов парсера ограничений.
- Планировщик добавляет каждое ограничение во внутренний список extra_constraints.
- Устанавливает значение is_solution_valid в false.

### Настройка решателя
- Пользователь задаёт, к примеру, time_limit=10, verbose=True.
- Планировщик передает соответствующие параметры модели, которая выполняет нужную внутреннюю конфигурацию,например, устанавливает значение scip_params["limits/time"].

### Построение/обновление модели, вычисление результата
При вызове scheduler.solve(...), если is_solution_valid = false:
- Создаётся (или пересобирается) MILP-модель:
  - Подключаются базовые ограничения.
  - Применяются все дополнительные ограничения из extra_constraints.
  - Формируется целевая функция.
- Вызывается solver.solve().
- Результат (массив x[i,j], s[j] и т.д.) преобразуется в удобный формат расписания.
- Внутренний кеш результатов обновляется, is_solution_valid = true.

### Использование результата
- Пользователь может получить текущее расписание и суммарную награду методом scheduler.get_schedule().
- Если в какой-то момент пользователь добавляет новое ограничение (или меняет его), is_solution_valid снова сбрасывается в false, требуя повторного solve().

## Вывод

Данный подход удовлетворяет требованию "универсального планировщика": можно динамически определять, какие ограничения применять, формировать разные целевые функции, подключать разные решатели, без переписывания базового алгоритма.